<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jairus</title>
  <style>
    body {
  background-color: black;
  color: white;
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  position: relative;
}

h1 {
  font-size: 36px;
  text-align: center;
  font-family: monospace;
  position: absolute;
  top: 20%; /* Adjust the top position as needed */
  margin-top: -18px; /* Adjust the margin-top to center vertically */
}

canvas {
  display: block;
}

  </style>
</head>

<body>
  <canvas id="cnvs"></canvas>
  <h1>
    <pre id="text">
▀█▀ ▀ █▄█   ▀▀█ █▀█ ▀█▀ █▀▄ █ █ █▀▀  
 █    █ █     █ █▀█  █  █▀▄ █ █ ▀▀█  
▀▀▀   ▀ ▀   ▀▀  ▀ ▀ ▀▀▀ ▀ ▀ ▀▀▀ ▀▀▀ ▀
- Press any key to start -
</pre>
  </h1>
</body>
<script>
  const joeTextOne = `
     ██  ██████  ███████ ██ 
     ██ ██    ██ ██      ██ 
     ██ ██    ██ █████   ██ 
██   ██ ██    ██ ██         
 █████   ██████  ███████ ██ 
                            
`;

  const joeTextTwo = `
     ██╗ ██████╗ ███████╗██╗
     ██║██╔═══██╗██╔════╝██║
     ██║██║   ██║█████╗  ██║
██   ██║██║   ██║██╔══╝  ╚═╝
╚█████╔╝╚██████╔╝███████╗██╗
 ╚════╝  ╚═════╝ ╚══════╝╚═╝
`;

  const joeWho = `
     ██  ██████  ███████     ██     ██ ██   ██  ██████  ██████  
     ██ ██    ██ ██          ██     ██ ██   ██ ██    ██      ██ 
     ██ ██    ██ █████       ██  █  ██ ███████ ██    ██   ▄███  
██   ██ ██    ██ ██          ██ ███ ██ ██   ██ ██    ██   ▀▀    
 █████   ██████  ███████      ███ ███  ██   ██  ██████    ██    
                                                                
`;

  const mommaTextOne = `
     ██  ██████  ███████ 
     ██ ██    ██ ██      
     ██ ██    ██ █████   
██   ██ ██    ██ ██      
 █████   ██████  ███████ 

███    ███  ██████  ███    ███ ███    ███  █████  ██ 
████  ████ ██    ██ ████  ████ ████  ████ ██   ██ ██ 
██ ████ ██ ██    ██ ██ ████ ██ ██ ████ ██ ███████ ██ 
██  ██  ██ ██    ██ ██  ██  ██ ██  ██  ██ ██   ██    
██      ██  ██████  ██      ██ ██      ██ ██   ██ ██ 
`;

  const mommaTextTwo = `
     ██╗ ██████╗ ███████╗
     ██║██╔═══██╗██╔════╝
     ██║██║   ██║█████╗  
██   ██║██║   ██║██╔══╝  
╚█████╔╝╚██████╔╝███████╗
 ╚════╝  ╚═════╝ ╚══════╝
███╗   ███╗ ██████╗ ███╗   ███╗███╗   ███╗ █████╗ ██╗
████╗ ████║██╔═══██╗████╗ ████║████╗ ████║██╔══██╗██║
██╔████╔██║██║   ██║██╔████╔██║██╔████╔██║███████║██║
██║╚██╔╝██║██║   ██║██║╚██╔╝██║██║╚██╔╝██║██╔══██║╚═╝
██║ ╚═╝ ██║╚██████╔╝██║ ╚═╝ ██║██║ ╚═╝ ██║██║  ██║██╗
╚═╝     ╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝
`;

  const gotchaText = ``

  let interval;

  let done = false;
  onkeydown = () => {
    if (done) return;
    done = true;
    const textElement = document.getElementById("text");
    textElement.textContent = joeTextOne;

    setTimeout(() => {
      textElement.textContent = joeWho;
    }, 2000);

    let mommaToggle = true;
    setTimeout(() => {
      interval = setInterval(() => {
        textElement.textContent = (mommaToggle = !mommaToggle) ? mommaTextOne : mommaTextTwo;
      }, 75);
    }, 4000);
    /*
        setTimeout(() => {
          clearInterval(interval);
          setInterval(() => {
            
          }, 1000);
        }, 7000);*/
  }
  onclick = onkeydown;


  const canvas = document.getElementById("cnvs");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const particles = [];
    const gridSize = 50;
    const grid = new Map();

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dx = Math.random() * 2 - 1;
        this.dy = Math.random() * 2 - 1;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = Math.random() * 0.05 - 0.025;
        this.gridX = Math.floor(this.x / gridSize);
        this.gridY = Math.floor(this.y / gridSize);
        this.addToGrid();
      }

      update() {
        this.removeFromGrid();
        this.x += this.dx;
        this.y += this.dy;
        this.rotation += this.rotationSpeed;
        this.gridX = Math.floor(this.x / gridSize);
        this.gridY = Math.floor(this.y / gridSize);
        this.addToGrid();
        if (this.x < 0 || this.x > canvas.width) this.dx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.dy *= -1;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.beginPath();
        ctx.moveTo(0, -10); // Top
        ctx.lineTo(10, 10); // Bottom right
        ctx.lineTo(-10, 10); // Bottom left
        ctx.closePath();
        ctx.fillStyle = "white";
        ctx.fill();
        ctx.restore();
      }

      drawLines(neighbors) {
        neighbors.forEach(neighbor => {
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(neighbor.x, neighbor.y);
          ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
          ctx.stroke();
        });
      }

      addToGrid() {
        const key = `${this.gridX},${this.gridY}`;
        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(this);
      }

      removeFromGrid() {
        const key = `${this.gridX},${this.gridY}`;
        if (grid.has(key)) {
          const index = grid.get(key).indexOf(this);
          if (index !== -1) grid.get(key).splice(index, 1);
        }
      }

      getNeighbors() {
        const neighbors = [];
        for (let x = this.gridX - 1; x <= this.gridX + 1; x++) {
          for (let y = this.gridY - 1; y <= this.gridY + 1; y++) {
            const key = `${x},${y}`;
            if (grid.has(key)) {
              grid.get(key).forEach(particle => {
                if (particle !== this) neighbors.push(particle);
              });
            }
          }
        }
        return neighbors;
      }
    }

    for (let i = 0; i < 100; i++) {
      particles.push(new Particle(Math.random() * canvas.width, Math.random() * canvas.height));
    }

    function animate() {
      requestAnimationFrame(animate);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const particle of particles) {
        particle.update();
        particle.draw();
        const neighbors = particle.getNeighbors();
        particle.drawLines(neighbors);
      };
    }

    animate();
</script>

</html>